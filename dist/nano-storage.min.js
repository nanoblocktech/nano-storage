!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).NanoStorage=t()}(this,(function(){"use strict";var e=function(){return e=Object.assign||function(e){for(var t,s=1,r=arguments.length;s<r;s++)for(var n in t=arguments[s])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},e.apply(this,arguments)},t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:global;"undefined"==typeof Promise||t.Promise||(t.Promise=Promise);class s{constructor(e){this.database=e,this.versionCode=1,this.storages={},this.db=null,this.isOpening=!1}version(e){return this.versionCode=e,this}stores(e){for(const t in e)if(e.hasOwnProperty(t)){const s=e[t];this[t]=new r(this,t,s),this.storages[t]={config:s,table:t}}}close(){this.isOpen()&&this.db.close(),this.isOpening=!1}isOpen(){return null!==this.db}async open(e=!1){return this.isOpening=!0,e?new t.Promise(((e,t)=>{this.initializeOpen().then((()=>{e(this)})).catch((e=>{t(e)}))})):this.initializeOpen().then((()=>this))}async initializeOpen(){if(!this.isOpen())return new t.Promise(((e,s)=>{const r=t.indexedDB.open(this.database,this.versionCode);if(!r)return this.logError("Failed to open database"),void s("Failed to open database");r.onblocked=e=>{this.logError("Please close all other tabs with this site open!")},r.onupgradeneeded=e=>{const t=e.target.result;for(const e in this.storages){const r=t.objectStoreNames.contains(e);if(this.storages.hasOwnProperty(e)&&!r){const r=this.storages[e].config,n=t.createObjectStore(e,{keyPath:"key",autoIncrement:!0}),i=r.split(",");for(var s=0;s<i.length;s++){const e=i[s]?.trim();let t="key"==e;n.createIndex(e,e,{unique:t})}}}},r.onsuccess=t=>{this.db=t.target.result,e()},r.onerror=e=>{s(e.target.error)}}))}newDatabase(){this.db.onversionchange=e=>{this.close(),this.logError("A new version of this page is ready. Please reload or close this tab!")}}delete(){return new t.Promise(((e,s)=>{const r=t.indexedDB.deleteDatabase(this.database);r.onsuccess=()=>{this.db=null,e(!0)},r.onerror=e=>{s(e.target.error)}}))}getStore(e,t){if(this.isOpen()){const s=this.db.transaction([e],t),r=s.objectStore(e);return s.oncomplete=function(){},r}return this.logError("Database is not open"),null}}class r{constructor(e,t,s){this.instance=e,this.baseTable=t,this.config=s,this.column=null,this.findKey=null,this.isOpening=!1}where(e){return this.column=e,this}equals(e){return this.findKey=this.toKey(e),this}async count(e){return this.shouldProceed()?this.instance.open(!0).then((()=>this.privateCount(e))).catch((e=>{this.throwError(e)})):this.databaseConnError()}privateCount(e){return new t.Promise(((t,s)=>{if(null==this.findKey)s({message:"Cache key cannot be empty "+this.findKey,status:0});else{const r=this.instance.getStore(this.baseTable,"readonly"),n=void 0!==e&&"function"==typeof e;if(null==r)s(this.dbError());else{let i=null;if(null==this.column)i=r.get(this.findKey);else{i=r.index(this.column).count(IDBKeyRange.only(this.findKey))}i.onsuccess=s=>{const r=s.target.result;n&&e(r),t(r)},i.onerror=t=>{n&&e(0),s(0)}}this.privateReset()}}))}async get(e){return this.shouldProceed()?this.instance.open(!0).then((()=>this.privateGet(e))).catch((e=>{this.throwError(e)})):this.databaseConnError()}privateGet(e){const s=this.instance.getStore(this.baseTable,"readonly");let r=null;if(null!=s)if(void 0===e.key){const t=Object.keys(e);if(1===t.length&&"key"!==t[0]){const n=s.index(t[0]);r=n.get(this.toKey(e[t[0]]))}else r=s.get(this.toKey(e.key))}else r=s.get(this.toKey(e.key));return new t.Promise(((e,t)=>{null==r?t(this.dbError()):(r.onsuccess=t=>{e(t.target.result)},r.onerror=s=>{e(void 0),t(s.target.error)})}))}async put(e,t=!1){return this.shouldProceed()?this.instance.open(!0).then((()=>this.privatePut(e,t))).catch((e=>{this.throwError(e)})):this.databaseConnError()}privatePut(e,s=!1){const r=this.instance.getStore(this.baseTable,"readwrite");let n=!1,i=null;return e.key&&null!=r&&(e.key=this.toKey(e.key),i=r.put(e)),s?new t.Promise(((t,s)=>{e.key?null==r?s(this.dbError()):(i.onsuccess=()=>{t(!0)},i.onerror=e=>{s(e.target.error)}):s("Cache key is missing or invalid")})):(e.key&&null!=r&&(i.onsuccess=()=>{n=!0},i.onerror=e=>{this.logError(e.target.error)}),n)}delete(){return this.shouldProceed()?this.instance.open(!0).then((()=>this.privateDelete())).catch((e=>{this.throwError(e)})):this.databaseConnError()}privateDelete(){return new t.Promise(((e,t)=>{if(null==this.findKey)t("Cache key cannot be empty");else{const s=this.instance.getStore(this.baseTable,"readwrite");if(null==s)t(this.dbError());else{let r=null;if(null==this.column)r=s.delete(this.findKey),r.onsuccess=()=>{e(!0)},r.onerror=e=>{t(e.target.error)};else{s.index(this.column).openCursor(IDBKeyRange.only(this.findKey)).onsuccess=s=>{const n=s.target.result;n?(r=n.delete(),r.onsuccess=()=>{e(!0)},r.onerror=e=>{t(e.target.error)}):t("No matching record found")}}}this.privateReset()}}))}clear(){return this.shouldProceed()?this.instance.open(!0).then((()=>this.privateClear())).catch((e=>{this.throwError(e)})):this.databaseConnError()}privateClear(){return new t.Promise(((e,t)=>{const s=this.instance.getStore(this.baseTable,"readwrite");if(null==s)t(this.dbError());else{const r=s.clear();r.onsuccess=()=>{e(!0)},r.onerror=e=>{t(e.target.error)}}}))}databaseConnError(){return t.Promise.reject({message:"Database is not open",status:500})}shouldProceed(){const e=this.instance.isOpening&&!this.instance.isOpen()||this.instance.isOpen();return e}logError(e){}throwError(e){this.logError(e);throw{message:e.message,status:500}}dbError(){return{message:"Database connection error",status:0}}privateReset(){this.column=null,this.findKey=null}toKey(e){let t=e?.trim().toLowerCase();return t=t.split(" ").pop(),t}}var n=Object.freeze({__proto__:null,NanoStorage:s,default:s});return e(s,n,{default:s}),s}));
